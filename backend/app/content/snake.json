{
    "id": "snake",
    "title": "Project: Build Snake",
    "difficulty": "Hard",
    "description": "Build the complete Snake game from scratch. You will implement movement, food consumption, and collision detection.",
    "steps": [
        {
            "id": 1,
            "title": "The Snake Game",
            "description": "Your goal is to complete the `main.py` file to make a working Snake game.",
            "notes": "### Project Guide\n\nWelcome to the Snake Project! You have a boilerplate file with the game loop and visualization setup. Your job is to fill in the missing logic.\n\n#### 1. Snake Representation\nThe snake is a list of coordinates: `[(row, col), (row, col), ...]`. The first element is the head.\n\n#### 2. Movement\nTo move, calculate the new head position based on the `direction`. Add it to the front of the list. If you didn't eat food, remove the tail.\n\n#### 3. Collision\nThe game ends if:\n- The head hits a wall (row < 0 or row >= 10).\n- The head hits its own body (`head in snake`).\n\n#### 4. Food\nIf `head == food`, don't remove the tail (the snake grows!).\n\nGood luck!",
            "goal": "Complete the TODO sections in the code to make the snake move, eat, and die.",
            "boilerplate_code": "import time\n\n# --- Constants ---\nGRID_SIZE = 10\nUP = (-1, 0)\nDOWN = (1, 0)\nLEFT = (0, -1)\nRIGHT = (0, 1)\n\n# --- Global State ---\nsnake = [(5, 5), (5, 4), (5, 3)] # Head is first\nfood = (5, 8)\ndirection = RIGHT\nscore = 0\ngame_over = False\n\ndef get_new_head(head, direction):\n    \"\"\"Calculates the new head position.\"\"\"\n    # TODO: Return a tuple (row, col) for the new head\n    return (head[0] + direction[0], head[1] + direction[1])\n\ndef check_collision(head, snake):\n    \"\"\"Returns True if collision with wall or self.\"\"\"\n    row, col = head\n    \n    # TODO: Check walls (0 to GRID_SIZE-1)\n    if row < 0 or row >= GRID_SIZE or col < 0 or col >= GRID_SIZE:\n        return True\n        \n    # TODO: Check self collision\n    if head in snake:\n        return True\n        \n    return False\n\ndef game_step():\n    \"\"\"Runs one frame of the game.\"\"\"\n    global snake, food, score, game_over\n    \n    if game_over:\n        return\n        \n    head = snake[0]\n    new_head = get_new_head(head, direction)\n    \n    if check_collision(new_head, snake):\n        game_over = True\n        print(f\"Game Over! Score: {score}\")\n        return\n        \n    # Move Snake\n    snake.insert(0, new_head)\n    \n    # Check Food\n    if new_head == food:\n        score += 1\n        print(f\"Yum! Score: {score}\")\n        # Simple food respawn (could overlap snake, but simple for now)\n        import random\n        food = (random.randint(0, GRID_SIZE-1), random.randint(0, GRID_SIZE-1))\n    else:\n        # TODO: What happens if we didn't eat food?\n        snake.pop()\n\n# --- Main Loop (Simulated) ---\n# In a real app, this runs in a loop. Here we run a few steps.\nprint(\"Starting Game...\")\nfor i in range(5):\n    game_step()\n    print(f\"Step {i+1}: Snake={snake}, Food={food}\")\n    \n# This variable is used by the Visualizer\ngame_state = {\n    \"snake\": snake,\n    \"food\": food,\n    \"score\": score,\n    \"game_over\": game_over\n}",
            "solution_code": "import time\nimport random\n\nGRID_SIZE = 10\nUP = (-1, 0)\nDOWN = (1, 0)\nLEFT = (0, -1)\nRIGHT = (0, 1)\n\nsnake = [(5, 5), (5, 4), (5, 3)]\nfood = (5, 8)\ndirection = RIGHT\nscore = 0\ngame_over = False\n\ndef get_new_head(head, direction):\n    return (head[0] + direction[0], head[1] + direction[1])\n\ndef check_collision(head, snake):\n    row, col = head\n    if row < 0 or row >= GRID_SIZE or col < 0 or col >= GRID_SIZE:\n        return True\n    if head in snake:\n        return True\n    return False\n\ndef game_step():\n    global snake, food, score, game_over\n    if game_over: return\n        \n    head = snake[0]\n    new_head = get_new_head(head, direction)\n    \n    if check_collision(new_head, snake):\n        game_over = True\n        return\n        \n    snake.insert(0, new_head)\n    \n    if new_head == food:\n        score += 1\n        food = (random.randint(0, GRID_SIZE-1), random.randint(0, GRID_SIZE-1))\n    else:\n        snake.pop()\n\n# Run a few steps for demo\nfor _ in range(5):\n    game_step()\n\ngame_state = {\"snake\": snake, \"food\": food, \"score\": score, \"game_over\": game_over}",
            "hints": [
                "If you don't eat food, you must remove the tail to keep the same length.",
                "Use `snake.pop()` to remove the last element."
            ]
        }
    ]
}